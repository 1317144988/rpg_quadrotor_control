#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <stdint.h>
#include <poll.h>

#include "ros/ros.h"
#include <std_msgs/Duration.h>
#include "quad_msgs/Px4Timesync.h"

#include "rpg_single_board_io/gpio.h"

#include <quad_common/parameter_helper.h>

// Loaded from ROS Parameters:
int n_msgs_for_sync_stable; // Number of sync messages that must be received before time synchronization is considered stable
double sync_msg_timeout; // Timeout for incoming sync packets after a trigger signal was detected [s]
double lambda; // Filter constant

int num_gpio = -1; // Trigger gpio

// Callback data
int64_t sync_msg_id = 0; // ID of a trigger event generated by the PX4
uint64_t px4_time_of_trigger_event; // PX4 time at which the last trigger event was generated [us]

bool px4_sync_msg_received = false; // Trigger message received flag; set by syncCallback

void syncCallback(const quad_msgs::Px4Timesync::ConstPtr& msg)
{
  sync_msg_id = msg->sync_id;

  px4_time_of_trigger_event = msg->time_px4;

  px4_sync_msg_received = true;

  // ROS_INFO("[%s] Received sync msg with ID %li", ros::this_node::getName().c_str(), sync_msg_id);
}

bool loadParameters()
{
  if (!quad_common::getParam("n_msgs_for_sync_stable", n_msgs_for_sync_stable))
  {
    ROS_ERROR("[%s] Failed to load parameter: n_msgs_for_sync_stable", ros::this_node::getName().c_str());
  }
  if (!quad_common::getParam("sync_msg_timeout", sync_msg_timeout))
  {
    ROS_ERROR("[%s] Failed to load parameter: sync_msg_timeout", ros::this_node::getName().c_str());
  }
  if (!quad_common::getParam("PX4TIMESYNC/gpio", num_gpio))
  {
    ROS_ERROR("[%s] Failed to load parameter: PX4TIMESYNC/gpio", ros::this_node::getName().c_str());
  }
  if (!quad_common::getParam("lambda", lambda))
  {
    ROS_ERROR("[%s] Failed to load parameter: lambda", ros::this_node::getName().c_str());
  }

  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "px4_timesync_node");
  ros::NodeHandle nh;

  ROS_INFO("[%s] Started PX4 Time Sync Node", ros::this_node::getName().c_str());

  if (!loadParameters())
  {
    ros::shutdown();
  }

  // Open GPIO; Adjust PORTS in PARAM file
  rpg_single_board_io::GPIO gpio(num_gpio, rpg_single_board_io::GpioEdge::Rising);

  if (!gpio.gpioIsOpen())
  {
    ROS_ERROR("[%s] Error while opening GPIO, exiting", ros::this_node::getName().c_str());
    ros::shutdown();
  }

  // Subscribe to timesync packages
  ros::Subscriber px4_timesync_msg_sub = nh.subscribe("px4_timesync_msg", 1, syncCallback);

  // Publish Time offset
  ros::Publisher px4_time_offset_pub = nh.advertise<std_msgs::Duration>("px4_time_offset", 1);

  // offset low pass
  ros::Duration offset_old = ros::Duration(0.0);

  // Check for stable timesync; count successful syncs in sync_stable_counter and
  // set sync_stable true if STABLE_SYNC_COUNT has been reached
  // --> time offset will be published only if sync is stable
  bool sync_stable = false;
  int sync_stable_counter = 0;

  int64_t trigger_count = 0; // count triggered syncs
  int trigger_count_offset = 0; // Offset between trigger_count and sync_id of px4

  float min_timesync_offset_ = 1e-4; // Minimum time offset considered as non zero

  ros::Time time_trigger_signal_detected; // ROS time at which we detect the interrupt on the GPIO from the PX4's trigger event

  int len, rc;
  const int max_buf_length = 64;
  char *buf[max_buf_length];
  int poll_timeout = 5000;

  int nfds = 1;
  struct pollfd fdset[1];
  memset((void*)fdset, 0, sizeof(fdset));

  fdset[0].fd = gpio.gpioGetFd();
  fdset[0].events = POLLPRI;

  while (nh.ok())
  {
    rc = poll(fdset, nfds, poll_timeout);

    if (rc < 0)
    {
      ROS_WARN("[%s] Poll failed!", ros::this_node::getName().c_str());
    }
    if (rc == 0)
    {
      ROS_WARN("[%s] Poll Timeout!", ros::this_node::getName().c_str());

      // Send 0 offset to indicate timeout
      std_msgs::Duration offset_msg;
      offset_msg.data = ros::Duration(0.0);

      px4_time_offset_pub.publish(offset_msg);
    }

    if (fdset[0].revents & POLLPRI)
    {
      time_trigger_signal_detected = ros::Time::now();

      lseek(fdset[0].fd, 0, SEEK_SET);
      char buf[max_buf_length];
      len = read(fdset[0].fd, buf, max_buf_length);

      // ROS_INFO("Trigger signal detected.");

      // Wait for answer with timeout
      ros::Rate loop_rate(100.0);
      px4_sync_msg_received = false;
      while (!px4_sync_msg_received
          && (ros::Duration(ros::Time::now() - time_trigger_signal_detected) < ros::Duration(sync_msg_timeout)))
      {
        ros::spinOnce();
        loop_rate.sleep();
      }

      if (px4_sync_msg_received)
      {
        if (sync_stable)
        {
          int id_offset = sync_msg_id - trigger_count;

          if ((trigger_count_offset != 0) && (id_offset != trigger_count_offset))
          {
            ROS_WARN("[%s] Possibly Package loss!", ros::this_node::getName().c_str());
            trigger_count_offset = id_offset;
          }

          std_msgs::Duration offset_msg;

          const double time_offset_meas = time_trigger_signal_detected.toSec()
              - (px4_time_of_trigger_event / 1000000.0);
          if (fabs(offset_old.toSec()) > min_timesync_offset_)
          {
            offset_msg.data = ros::Duration(lambda * time_offset_meas + (1.0 - lambda) * offset_old.toSec());
          }
          else
          {
            offset_msg.data = ros::Duration(time_offset_meas);
          }

          px4_time_offset_pub.publish(offset_msg);

          offset_old = offset_msg.data;
        }
        else
        {
          if (sync_stable_counter >= n_msgs_for_sync_stable)
          {
            ROS_INFO("[%s] Timesync is stable, publishing time offsets now.", ros::this_node::getName().c_str());
            offset_old = ros::Duration(0.0);
            sync_stable = true; // stable_sync is established!
          }
          else
          {
            sync_stable_counter++;
          }
        }
      }
      else
      {
        ROS_WARN("[%s] No sync message received within timeout of %f!", ros::this_node::getName().c_str(),
                 sync_msg_timeout);

        // reset all sync_stable indicators
        sync_stable = false;
        sync_stable_counter = 0;
        trigger_count_offset = 0;

        // Send 0 offset to indicate timeout
        std_msgs::Duration offset_msg;
        offset_msg.data = ros::Duration(0.0);

        px4_time_offset_pub.publish(offset_msg);
      }

    } // ENDIF POLL

    ros::spinOnce();
  }

  return 0;
}
